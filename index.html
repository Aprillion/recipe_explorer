<html>
<head>
  <meta charset="utf-8">
  <title>Factorio recipes</title>
  <style>
    div {
      display: flex;
      align-items: flex-start;
    }
    img {
      height: 16px;
      width: 16px;
      padding: 1px;
    }
    .big_icon > img {
      height: 32px;
      width: 32px;
    }
    .grid {
      font: 16px "Calibri", serif;
      line-height: 18px;
      flex-wrap: wrap;
      margin: auto;
    }
    .tier {
      flex-direction: column;
      flex: 1 0 0;
      align-items: center;
      max-width: 150px;
      background: rgba(0, 0, 50, .1);
    }
    .tier:nth-child(8n+2) {
      background: rgba(0, 0, 50, .2);
    }
    .tier:nth-child(8n+3) {
      background: rgba(0, 0, 50, .3);
    }
    .tier:nth-child(8n+4) {
      background: rgba(0, 0, 50, .4);
    }
    .tier:nth-child(8n+5) {
      background: rgba(0, 0, 50, .5);
    }
    .tier:nth-child(8n+6) {
      background: rgba(0, 0, 50, .6);
      color: white;
    }
    .tier:nth-child(8n+7) {
      background: rgba(0, 0, 50, .7);
      color: white;
    }
    .tier:nth-child(8n) {
      background: rgba(0, 0, 50, .8);
      color: white;
    }
    .recipe {
      margin: 5px;
      min-height: 100px;
      min-width: 120px;
      justify-content: center;
    }
    .enabled .big_icon_and_time {
      background: #efd;
    }
    .researched .big_icon_and_time {
      background: #0f0; /* only if technologies.json is more up to date than recipes.json */
    }
    .next .big_icon_and_time {
      background: #ffc;
    }
    .reachable .big_icon_and_time {
      background: #fdd;
    }
    .unreachable .big_icon_and_time {
      background: #ccc;
    }
    .ingredients,
    .big_icon_and_time,
    .products {
      flex-direction: column;
      flex: 1 0 0;
    }
    .ingredients {
      align-items: flex-end;
    }
    .big_icon_and_time {
      font-size: 14px;
      padding: 1px;
      color: black;
      align-items: center;
    }
    .big_icon_and_time > img {
      padding: 1px 3px;
    }
    .technology {
      padding-left: 5px;
    }
    
  </style>
</head>
<body>
  <div id="root">Loading icons...</div>
  <script>
  // (() => { // keep in global namespace while debugging
    const root = document.getElementById('root')
    const icon_urls = [
      'known_icons',
      // '/Applications/factorio.app/Contents/data/base/graphics/icons/fluid',
      // '/Applications/factorio.app/Contents/data/base/graphics/icons', // TODO: widows, linux, mods folders, ...
      // '/Applications/factorio.app/Contents/data/base/graphics/technology',
      // 'https://wiki.factorio.com/images',
    ]
    const icons = {}
    const icons_promise = []
    let items = {}
    let recipes_obj = {}
    let recipe_tiers = {}
    let recipes
    let technologies

    // local files only work in Firefox => TODO: start a server, add a file chooser?
    let recipes_promise = fetch('game.player.force.recipes.json').then(r => r.json())
    const technologies_promise = fetch('game.player.force.technologies.json').then(r => r.json())
    Promise.all([recipes_promise, technologies_promise])
      .then(([r, t]) => {
        recipes = r
        technologies = t
      })
      .then(load_icons)
      .then(extract_items)
      .then(add_technologies)
      .then(sort_recipes)
      .then(remove_item_cycles)
      .then(categorize)
      .then(render_dom)
      .then(display_grid)
      // .then(() => {console.log('recipes', recipes))
    
    function load_icons() {
      add_icon({name: 'time-icon'})
      recipes.forEach(({name, ingredients, products}) => {
        add_icon({name})
        ingredients.forEach(ingredient => {
          add_icon({...ingredient})
        })
        products.forEach(product => {
          add_icon({...product})
        })
      })
      technologies.filter(t => t.effects.length && t.effects.some(e => e.type === 'unlock-recipe'))
        .forEach(({name}) => {
          name = name.replace(/-\d+$/, '')
          add_icon({name})
        })
      return Promise.all(icons_promise).then(() => [recipes, technologies])
    }
    
    function extract_items() {
      add_icon({name: 'time-icon'})
      recipes.forEach(recipe => {
        const {name, ingredients, products} = recipe
        recipes_obj[name] = recipe // mutable reference
        ingredients.forEach(ingredient => {
          add_item({item: ingredient.name, category: 'ingredients_in', value: name})
        })
        products.forEach(product => {
          add_item({item: product.name, category: 'products_in', value: name})
        })
      })
    }
    
    function add_technologies() {
      const chain = {}
      const recipe_unlocks = {}
      technologies.forEach(({name, effects, prerequisites, researched}) => {
        chain[name] = {
          researched,
          prerequisites: Object.keys(prerequisites)
        }
        effects.length && effects.filter(({type}) => type === 'unlock-recipe').forEach(({recipe}) => {
          recipe_unlocks[recipe] = name
        })
      })
      
      recipes.forEach(recipe => {
        const name = recipe_unlocks[recipe.name]
        const prereq_enabled = prereq => chain[prereq].researched
        let reachability = 'unreachable'
        if (chain[name]) {
          if (chain[name].researched) {
            reachability = 'researched'
          } else if (chain[name].prerequisites.every(prereq_enabled)) {
            reachability = 'next'
          } else {
            reachability = 'reachable'
          }
        }
        recipe.technology = {
          name,
          reachability,
          // TODO: calculate expense of reaching this technology including all predecesor (for storting => just sum the energy)
        }
      })
    }
    
    function sort_recipes() {
      const reachability_order = {
        [true]: 1, // 0 is falsey
        researched: 1.5,
        next: 2,
        reachable: 3,
        unreachable: 99
      }
      recipes.sort((a, b) => {
        const at = a.technology
        const bt = b.technology
        const atr = reachability_order[a.enabled || at.reachability]
        const btr = reachability_order[b.enabled || bt.reachability]
        if (atr - btr !== 0) { return atr - btr }
        
        const ao = a.order
        const bo = b.order
        if (ao < bo) { return -1 }
        if (ao > bo) { return 1 }
        return 0
      })
    }
    
    function remove_item_cycles() {
      Object.keys(items).forEach(iname => {
        const i = items[iname]
        i.products_without_cycles_in = i.products_in.filter(p => {
          if (i.ingredients_in.includes(p)) { return false }
          if (p.match(/^fill/)) { return true }  // keep filling barrels after "barrel" recipe + emptying barrels after filling
          return recipes_obj[p].ingredients.every(ingredient_of_p_recipe => {
            const i2 = items[ingredient_of_p_recipe.name]
            return i2.products_in.every(p2 => {
              return recipes_obj[p2].ingredients.every(ingredient_of_p2_recipe => {
                return ingredient_of_p2_recipe.name !== iname
                // TODO: test bigger cycles?
              })
            })
          })
        })
      })
    }
    
    function categorize() {
      let available = {}
      Object.keys(items).forEach(iname => {
        if (items[iname].products_without_cycles_in.length === 0) {
          available[iname] = true
        }
      })
      const tiers = [1, 2, 3, 4, 5, 6, 7, 8] // TODO: loop
      tiers.forEach(tier => {
        recipe_tiers[tier] = []
        const available_next = {}
        recipes.forEach(recipe => {
          if (recipe.tier) { return }
          const all_ingredients_available = recipe.ingredients.every(({name}) => available[name])
          if (all_ingredients_available) {
            recipe_tiers[tier].push(recipe)
            recipe.tier = tier
            recipe.products.forEach(({name}) => {
              available_next[name] = true
            })
          }
        })
        recipe_tiers[undefined] = []
        recipes.forEach(recipe => {
          if (recipe.tier) { return }
          recipe_tiers[undefined].push(recipe)
        })
        available = {...available, ...available_next}
      })
    }
    
    function render_dom() {
      recipes.forEach(recipe => {
        const {name, enabled, technology, ingredients, products, energy} = recipe
        const reachability = enabled ? 'enabled' : technology.reachability
        
        const ingredient_icons = div('ingredients', ingredients.map(item => (
          div(null, [
            div(null, amount(item)),
            img(item.name)
          ]))
        ))
        const big_icon_and_time = div('big_icon_and_time', [
          div('big_icon', img(name)),
          div('time', [
            img('time-icon'),
            energy
          ]),
          technology.name && div('technology', ['T:', img(technology.name)])
        ])
        const show_products = true // products.length > 1 || products[0].name !== name || products[0].amount !== 1
        let product_icons = ''
        if (show_products) {
          product_icons = div('products', products.map(item => (
            div(null, [
              img(item.name),
              amount(item)
            ]))
          ))
        }
        
        recipe.dom = div(`recipe ${reachability}`, [ingredient_icons, big_icon_and_time, product_icons])
       })
    }
    
    function display_grid() {
      root.innerText = ''
      const tier_columns = []
      Object.keys(recipe_tiers).forEach(tier => {
        recipe_tiers[tier].length > 0 && tier_columns.push(recipe_tiers[tier])
      })
      root.appendChild(div("grid", tier_columns.map(tier => {
        return div("tier", tier.map(recipe => recipe.dom))
      })))
    }
    
    // ### Utils ###
    
    function add_icon({name, type}) {
      if (icons[name]) { return }
      const img = new Image()
      icons[name] = img
      img.alt = name
      img.title = name
      
      // try multiple url prefixes when loading fails
      const remaining_urls = [...icon_urls].reverse()
      icons_promise.push(new Promise((resolve, reject) => {
        const change_src = () => {
          let url = remaining_urls.pop()
          if (url.match('wiki.factorio.com')) {
            url = `${url}/${name.charAt(0).toUpperCase() + name.slice(1).replace(/-(?!\d)/g, '_')}.png`
          } else {
            url = `${url}/${name}.png`
          }
          if (remaining_urls.length === 0) {
            img.onerror = () => console.warn('icon not found:', name) // before setting src
            resolve() // do not reject because Promise.all should wait for all
          }
          img.src = url
        }
        img.onerror = change_src
        img.onload = () => resolve()
        change_src()
      }))
    }
    
    function add_item({item, category, value}) {
      if (!items[item]) {
        items[item] = {ingredients_in: [], products_in: [], products_without_cycles_in: []}
      }
      items[item][category].push(value)
    }
    
    function amount(item) {
      if (item.amount) {
        return item.amount === 1 ? '' : item.amount
      }
      return item.probability * (item.amount_min + item.amount_max) / 2
    }
    
    // ### DOM library placeholder ###
    
    function div(className, children) {
      const el = document.createElement('div')
      if (className) {
        el.className = className
      }
      if (!Array.isArray(children)) {
        children = [children]
      }
      children.forEach(child => {
        if (child instanceof HTMLElement) {
          el.appendChild(child)
        } else if (child != undefined) {
          el.appendChild(document.createTextNode(child))
        }
      })
      return el
    }
    
    function img(name) {
      const img = new Image()
      img.title = name
      if (!icons[name]) {
        name = name.replace(/-\d+$/, '')
      }
      img.alt = name
      if (icons[name]) {
        img.src = icons[name].src
      } else {
        console.warn('icon not prefetched: ', name)
      }
      return img
    }
  // })()
  </script>
</body>
</html>
